-----------------------------
-- Drop everything first to ensure clean slate
-----------------------------
DROP SCHEMA public CASCADE;
CREATE SCHEMA public;

-- Reset permissions
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO anon;
GRANT ALL ON SCHEMA public TO authenticated;
GRANT ALL ON SCHEMA public TO service_role;

-----------------------------
-- 1. Extensions
-----------------------------
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
-- Consider adding pg_cron for scheduled tasks if available and needed.
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-----------------------------
-- 2. Custom Types
-----------------------------
CREATE TYPE sentiment_type AS ENUM ('positive', 'neutral', 'negative');
CREATE TYPE subscription_status AS ENUM ('active', 'cancelled', 'expired', 'trial');
CREATE TYPE message_frequency AS ENUM ('daily', 'weekly', 'monthly');
CREATE TYPE plan_type AS ENUM ('free', 'basic', 'premium', 'vip');
CREATE TYPE priority_level AS ENUM ('low', 'medium', 'high');
CREATE TYPE message_content_type AS ENUM ('text', 'audio', 'image');
CREATE TYPE payment_status AS ENUM ('pending', 'completed', 'failed', 'refunded');

-----------------------------
-- 3. Core Tables
-----------------------------
-- Users with encryption
CREATE TABLE users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    auth_id UUID REFERENCES auth.users(id),
    phone_number_hash TEXT NOT NULL,
    phone_number_encrypted BYTEA,
    is_active BOOLEAN DEFAULT TRUE NOT NULL,
    settings JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    deleted_at TIMESTAMPTZ,
    version INT DEFAULT 1 NOT NULL
) PARTITION BY HASH(id);

-- Create user partitions
CREATE TABLE users_0 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE users_1 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE users_2 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE users_3 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 3);

-- User Preferences
CREATE TABLE user_preferences (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    preferred_persona_id BIGINT,
    message_frequency message_frequency DEFAULT 'daily',
    preferred_time_window JSONB,
    max_daily_messages INT DEFAULT 30 CHECK (max_daily_messages > 0),
    do_not_disturb BOOLEAN DEFAULT FALSE,
    notification_settings JSONB DEFAULT '{"sms": true, "email": false}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Personas
CREATE TABLE personas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE CHECK (LENGTH(name) > 0),
    system_prompt TEXT NOT NULL,
    description TEXT,
    personality_traits TEXT[],
    sample_messages TEXT[],
    required_plan plan_type DEFAULT 'free',
    is_active BOOLEAN DEFAULT TRUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    version INT DEFAULT 1 NOT NULL
);

-- Messages
CREATE TABLE messages (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    user_id BIGINT NOT NULL,
    persona_id BIGINT,
    conversation_id UUID DEFAULT gen_random_uuid() NOT NULL,
    user_message TEXT,
    ai_response TEXT,
    message_type message_content_type DEFAULT 'text' NOT NULL,
    sentiment sentiment_type DEFAULT 'neutral' NOT NULL,
    tags TEXT[],
    context JSONB,
    metadata JSONB DEFAULT '{}'::jsonb,
    user_message_url TEXT,
    ai_response_url TEXT,
    is_billable BOOLEAN DEFAULT FALSE,      -- Flag for billable messages (beyond free tier)
    billed BOOLEAN DEFAULT FALSE,           -- Whether this message has been billed
    search_vector TSVECTOR GENERATED ALWAYS AS (
        to_tsvector('english',
            COALESCE(user_message, '') || ' ' ||
            COALESCE(ai_response, '')
        )
    ) STORED,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    deleted_at TIMESTAMPTZ,
    version INT DEFAULT 1 NOT NULL,
    parent_message_id BIGINT, --for message threading
    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- Add Foreign Key Constraints to Messages
ALTER TABLE messages ADD CONSTRAINT messages_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
ALTER TABLE messages ADD CONSTRAINT messages_persona_id_fkey FOREIGN KEY (persona_id) REFERENCES personas(id) ON DELETE SET NULL;
ALTER TABLE messages
        ADD CONSTRAINT messages_parent_message_id_fkey
        FOREIGN KEY (parent_message_id, created_at) -- Referencing the composite PK
        REFERENCES messages (id, created_at)
        ON DELETE SET NULL;

-- Create initial message partitions
CREATE TABLE messages_2024_01 PARTITION OF messages
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE messages_2024_02 PARTITION OF messages
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
CREATE TABLE messages_2024_03 PARTITION OF messages
    FOR VALUES FROM ('2024-03-01') TO ('2024-04-01');
CREATE TABLE messages_2024_04 PARTITION OF messages
    FOR VALUES FROM ('2024-04-01') TO ('2024-05-01');
CREATE TABLE messages_2024_05 PARTITION OF messages
    FOR VALUES FROM ('2024-05-01') TO ('2024-06-01');
CREATE TABLE messages_2024_06 PARTITION OF messages
    FOR VALUES FROM ('2024-06-01') TO ('2024-07-01');
CREATE TABLE messages_2024_07 PARTITION OF messages
    FOR VALUES FROM ('2024-07-01') TO ('2024-08-01');
CREATE TABLE messages_2024_08 PARTITION OF messages
    FOR VALUES FROM ('2024-08-01') TO ('2024-09-01');
CREATE TABLE messages_2024_09 PARTITION OF messages
    FOR VALUES FROM ('2024-09-01') TO ('2024-10-01');
CREATE TABLE messages_2024_10 PARTITION OF messages
    FOR VALUES FROM ('2024-10-01') TO ('2024-11-01');
CREATE TABLE messages_2024_11 PARTITION OF messages
    FOR VALUES FROM ('2024-11-01') TO ('2024-12-01');
CREATE TABLE messages_2024_12 PARTITION OF messages
    FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');
CREATE TABLE messages_2025_01 PARTITION OF messages
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
CREATE TABLE messages_2025_02 PARTITION OF messages
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
CREATE TABLE messages_2025_03 PARTITION OF messages
    FOR VALUES FROM ('2025-03-01') TO ('2025-04-01');
CREATE TABLE messages_2025_04 PARTITION OF messages
    FOR VALUES FROM ('2025-04-01') TO ('2025-05-01');
CREATE TABLE messages_2025_05 PARTITION OF messages
    FOR VALUES FROM ('2025-05-01') TO ('2025-06-01');
CREATE TABLE messages_2025_06 PARTITION OF messages
    FOR VALUES FROM ('2025-06-01') TO ('2025-07-01');
CREATE TABLE messages_2025_07 PARTITION OF messages
    FOR VALUES FROM ('2025-07-01') TO ('2025-08-01');
CREATE TABLE messages_2025_08 PARTITION OF messages
    FOR VALUES FROM ('2025-08-01') TO ('2025-09-01');
CREATE TABLE messages_2025_09 PARTITION OF messages
    FOR VALUES FROM ('2025-09-01') TO ('2025-10-01');
CREATE TABLE messages_2025_10 PARTITION OF messages
    FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');
CREATE TABLE messages_2025_11 PARTITION OF messages
    FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
CREATE TABLE messages_2025_12 PARTITION OF messages
    FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

-- Message Limits (UPDATED for pay-as-you-go model)
CREATE TABLE message_limits (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    daily_count INT DEFAULT 0,
    weekly_count INT DEFAULT 0,
    monthly_count INT DEFAULT 0,
    billable_count INT DEFAULT 0,           -- Count of billable messages (beyond free tier)
    unbilled_amount NUMERIC(10, 4) DEFAULT 0, -- Amount not yet billed ($0.018 per billable message)
    last_billing_date TIMESTAMPTZ,          -- When the user was last billed
    last_reset_date DATE DEFAULT CURRENT_DATE,
    free_limit INT DEFAULT 30,              -- Free messages per day (default 30)
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Payment Methods
CREATE TABLE payment_methods (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider TEXT NOT NULL,                 -- 'stripe', etc.
    payment_token TEXT,                     -- Token from payment provider (encrypted)
    card_last_four CHAR(4),                 -- Last 4 digits of card
    card_brand TEXT,                        -- Visa, Mastercard, etc.
    expiry_month INT,
    expiry_year INT,
    is_default BOOLEAN DEFAULT FALSE,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Payment Transactions
CREATE TABLE payment_transactions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    payment_method_id BIGINT REFERENCES payment_methods(id),
    amount NUMERIC(10, 2) NOT NULL,
    currency TEXT DEFAULT 'USD',
    status payment_status DEFAULT 'pending',
    billable_messages_count INT,            -- Number of messages billed in this transaction
    billing_period_start TIMESTAMPTZ,       -- Start of billing period
    billing_period_end TIMESTAMPTZ,         -- End of billing period
    provider_transaction_id TEXT,           -- ID from payment provider
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Audit Log
CREATE TABLE audit_log (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    table_name TEXT NOT NULL,
    record_id BIGINT NOT NULL,
    operation TEXT NOT NULL,
    old_values JSONB,
    new_values JSONB,
    changed_by UUID REFERENCES auth.users(id),
    changed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    PRIMARY KEY (id, changed_at)
) PARTITION BY RANGE (changed_at);

-- Create audit log partitions
CREATE TABLE audit_log_2024_01 PARTITION OF audit_log
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE audit_log_2024_02 PARTITION OF audit_log
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
CREATE TABLE audit_log_2024_03 PARTITION OF audit_log
    FOR VALUES FROM ('2024-03-01') TO ('2024-04-01');
CREATE TABLE audit_log_2024_04 PARTITION OF audit_log
    FOR VALUES FROM ('2024-04-01') TO ('2024-05-01');
CREATE TABLE audit_log_2024_05 PARTITION OF audit_log
    FOR VALUES FROM ('2024-05-01') TO ('2024-06-01');
CREATE TABLE audit_log_2024_06 PARTITION OF audit_log
    FOR VALUES FROM ('2024-06-01') TO ('2024-07-01');
CREATE TABLE audit_log_2024_07 PARTITION OF audit_log
    FOR VALUES FROM ('2024-07-01') TO ('2024-08-01');
CREATE TABLE audit_log_2024_08 PARTITION OF audit_log
    FOR VALUES FROM ('2024-08-01') TO ('2024-09-01');
CREATE TABLE audit_log_2024_09 PARTITION OF audit_log
    FOR VALUES FROM ('2024-09-01') TO ('2024-10-01');
CREATE TABLE audit_log_2024_10 PARTITION OF audit_log
    FOR VALUES FROM ('2024-10-01') TO ('2024-11-01');
CREATE TABLE audit_log_2024_11 PARTITION OF audit_log
    FOR VALUES FROM ('2024-11-01') TO ('2024-12-01');
CREATE TABLE audit_log_2024_12 PARTITION OF audit_log
    FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');
CREATE TABLE audit_log_2025_01 PARTITION OF audit_log
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
CREATE TABLE audit_log_2025_02 PARTITION OF audit_log
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
CREATE TABLE audit_log_2025_03 PARTITION OF audit_log
    FOR VALUES FROM ('2025-03-01') TO ('2025-04-01');
CREATE TABLE audit_log_2025_04 PARTITION OF audit_log
    FOR VALUES FROM ('2025-04-01') TO ('2025-05-01');
CREATE TABLE audit_log_2025_05 PARTITION OF audit_log
    FOR VALUES FROM ('2025-05-01') TO ('2025-06-01');
CREATE TABLE audit_log_2025_06 PARTITION OF audit_log
    FOR VALUES FROM ('2025-06-01') TO ('2025-07-01');
CREATE TABLE audit_log_2025_07 PARTITION OF audit_log
    FOR VALUES FROM ('2025-07-01') TO ('2025-08-01');
CREATE TABLE audit_log_2025_08 PARTITION OF audit_log
    FOR VALUES FROM ('2025-08-01') TO ('2025-09-01');
CREATE TABLE audit_log_2025_09 PARTITION OF audit_log
    FOR VALUES FROM ('2025-09-01') TO ('2025-10-01');
CREATE TABLE audit_log_2025_10 PARTITION OF audit_log
    FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');
CREATE TABLE audit_log_2025_11 PARTITION OF audit_log
    FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
CREATE TABLE audit_log_2025_12 PARTITION OF audit_log
    FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

-- Feedback Table
CREATE TABLE feedback (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    message_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    rating TEXT CHECK (rating IN ('positive', 'negative', 'neutral')),
    user_comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    message_created_at TIMESTAMPTZ NOT NULL, -- For the composite foreign key
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    FOREIGN KEY (message_id, message_created_at) REFERENCES messages(id, created_at) ON DELETE CASCADE
);

-- Authentication Events (for security logging)
CREATE TABLE authentication_events (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
    event_type TEXT NOT NULL,
    ip_address INET,
    user_agent TEXT,
    event_data JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-----------------------------
-- 4. Security Implementation
-----------------------------
-- Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE message_limits ENABLE ROW LEVEL SECURITY;
ALTER TABLE feedback ENABLE ROW LEVEL SECURITY;
ALTER TABLE authentication_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE payment_methods ENABLE ROW LEVEL SECURITY;
ALTER TABLE payment_transactions ENABLE ROW LEVEL SECURITY;

-- Supabase RLS Policies
CREATE POLICY "Users can view own profile"
    ON users FOR SELECT
    USING (auth_id = auth.uid());

CREATE POLICY "Users can update own profile"
    ON users FOR UPDATE
    USING (auth_id = auth.uid());

CREATE POLICY "Users can view own messages"
    ON messages FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can create own messages"
    ON messages FOR INSERT
    WITH CHECK (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own preferences"
    ON user_preferences FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can update own preferences"
    ON user_preferences FOR UPDATE
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own message limits"
    ON message_limits FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own feedback"
    ON feedback FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can create feedback for own messages"
    ON feedback FOR INSERT
    WITH CHECK (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own payment methods"
    ON payment_methods FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can manage own payment methods"
    ON payment_methods FOR INSERT
    WITH CHECK (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own payment transactions"
    ON payment_transactions FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own auth events"
    ON authentication_events FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

-- RLS policies for Personas (public)
CREATE POLICY "Anyone can view active personas"
    ON personas FOR SELECT
    USING (is_active = TRUE);

-----------------------------
-- 5. Indexes
-----------------------------
-- Users
CREATE INDEX idx_users_auth ON users(auth_id);
CREATE INDEX idx_users_phone ON users(phone_number_hash);
CREATE INDEX idx_users_active ON users(is_active) WHERE is_active = TRUE;

-- Messages
CREATE INDEX idx_messages_user_created ON messages(user_id, created_at);
CREATE INDEX idx_messages_conversation ON messages(conversation_id, created_at);
CREATE INDEX idx_messages_search ON messages USING GIN(search_vector);
CREATE INDEX idx_messages_tags ON messages USING GIN(tags);
CREATE INDEX idx_messages_metadata ON messages USING GIN(metadata);
CREATE INDEX idx_messages_active ON messages(deleted_at) WHERE deleted_at IS NULL;
CREATE INDEX idx_messages_parent_message_id ON messages(parent_message_id);
CREATE INDEX idx_messages_billable ON messages(is_billable, billed) WHERE is_billable = TRUE;

-- User Preferences
CREATE INDEX idx_preferences_user ON user_preferences(user_id);

-- Message Limits
CREATE INDEX idx_message_limits_user ON message_limits(user_id);
CREATE INDEX idx_message_limits_billing ON message_limits(user_id, unbilled_amount) WHERE unbilled_amount > 0;

-- Payment Methods
CREATE INDEX idx_payment_methods_user ON payment_methods(user_id);
CREATE INDEX idx_payment_methods_default ON payment_methods(user_id, is_default) WHERE is_default = TRUE;

-- Payment Transactions
CREATE INDEX idx_payment_transactions_user ON payment_transactions(user_id);
CREATE INDEX idx_payment_transactions_status ON payment_transactions(status);
CREATE INDEX idx_payment_transactions_date ON payment_transactions(created_at);

-- Audit Log
CREATE INDEX idx_audit_log_table ON audit_log(table_name, record_id);
CREATE INDEX idx_audit_log_changed_by ON audit_log(changed_by);

-- Feedback
CREATE INDEX idx_feedback_message_id_created_at ON feedback(message_id, message_created_at);
CREATE INDEX idx_feedback_user_id ON feedback(user_id);

-- Authentication Events
CREATE INDEX idx_auth_events_user_id ON authentication_events(user_id);
CREATE INDEX idx_auth_events_event_type ON authentication_events(event_type);
CREATE INDEX idx_auth_events_created_at ON authentication_events(created_at);

-----------------------------
-- 6. Functions and Triggers
-----------------------------
-- Function to check if a message should be billable
CREATE OR REPLACE FUNCTION check_billable_message()
RETURNS TRIGGER AS $$
DECLARE
    free_limit INT;
    daily_count INT;
BEGIN
    -- Get user's free message limit and current count
    SELECT ml.free_limit, ml.daily_count INTO free_limit, daily_count
    FROM message_limits ml
    WHERE ml.user_id = NEW.user_id;
    
    -- If no record exists, create one with defaults
    IF free_limit IS NULL THEN
        INSERT INTO message_limits (user_id, daily_count, free_limit)
        VALUES (NEW.user_id, 1, 30)
        RETURNING free_limit, daily_count INTO free_limit, daily_count;
    ELSE
        -- Update the daily count
        UPDATE message_limits 
        SET daily_count = daily_count + 1
        WHERE user_id = NEW.user_id
        RETURNING daily_count INTO daily_count;
    END IF;
    
    -- Check if this message should be billable
    IF daily_count > free_limit THEN
        NEW.is_billable = TRUE;
        
        -- Update billable count and unbilled amount
        UPDATE message_limits
        SET billable_count = billable_count + 1,
            unbilled_amount = unbilled_amount + 0.018
        WHERE user_id = NEW.user_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to check if messages are billable
CREATE TRIGGER check_billable_message_trigger
BEFORE INSERT ON messages
FOR EACH ROW
EXECUTE FUNCTION check_billable_message();

-- Function to update modified_at column
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.modified_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for modified_at updates
CREATE TRIGGER update_users_modtime
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_messages_modtime
    BEFORE UPDATE ON messages
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_preferences_modtime
    BEFORE UPDATE ON user_preferences
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_message_limits_modtime
    BEFORE UPDATE ON message_limits
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_payment_methods_modtime
    BEFORE UPDATE ON payment_methods
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_payment_transactions_modtime
    BEFORE UPDATE ON payment_transactions
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_feedback_modtime
    BEFORE UPDATE ON feedback
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_auth_events_modtime
    BEFORE UPDATE ON authentication_events
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

-- Trigger function for audit logging
CREATE OR REPLACE FUNCTION audit_log_trigger_func()
RETURNS TRIGGER AS $$
DECLARE
    old_values JSONB;
    new_values JSONB;
BEGIN
    IF (TG_OP = 'UPDATE') THEN
        old_values := row_to_json(OLD)::jsonb;
        new_values := row_to_json(NEW)::jsonb;
    ELSIF (TG_OP = 'INSERT') THEN
        old_values := '{}'::jsonb;
        new_values := row_to_json(NEW)::jsonb;
    ELSIF (TG_OP = 'DELETE') THEN
        old_values := row_to_json(OLD)::jsonb;
        new_values := '{}'::jsonb;
    END IF;

    INSERT INTO audit_log (table_name, record_id, operation, old_values, new_values, changed_by)
    VALUES (TG_TABLE_NAME, (CASE WHEN TG_OP = 'DELETE' THEN OLD.id ELSE NEW.id END), TG_OP, old_values, new_values, auth.uid());

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create audit triggers
CREATE TRIGGER audit_users_trigger
AFTER INSERT OR UPDATE OR DELETE ON users
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_messages_trigger
AFTER INSERT OR UPDATE OR DELETE ON messages
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_user_preferences_trigger
AFTER INSERT OR UPDATE OR DELETE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_personas_trigger
AFTER INSERT OR UPDATE OR DELETE ON personas
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_message_limits_trigger
AFTER INSERT OR UPDATE OR DELETE ON message_limits
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_payment_methods_trigger
AFTER INSERT OR UPDATE OR DELETE ON payment_methods
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_payment_transactions_trigger
AFTER INSERT OR UPDATE OR DELETE ON payment_transactions
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_feedback_trigger
AFTER INSERT OR UPDATE OR DELETE ON feedback
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_auth_events_trigger
AFTER INSERT OR UPDATE OR DELETE ON authentication_events
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

-- Function to reset message counts (daily, weekly, monthly)
CREATE OR REPLACE FUNCTION reset_message_counts()
RETURNS VOID AS $$
BEGIN
    -- Reset daily counts if last reset date is not today
    UPDATE message_limits
    SET daily_count = 0,
        modified_at = NOW()
    WHERE last_reset_date < CURRENT_DATE;
    
    -- Reset weekly counts on Mondays
    IF EXTRACT(DOW FROM CURRENT_DATE) = 1 THEN
        UPDATE message_limits
        SET weekly_count = 0,
            modified_at = NOW();
    END IF;
    
    -- Reset monthly counts on the first day of the month
    IF EXTRACT(DAY FROM CURRENT_DATE) = 1 THEN
        UPDATE message_limits
        SET monthly_count = 0,
            modified_at = NOW();
    END IF;
    
    -- Update last reset date
    UPDATE message_limits
    SET last_reset_date = CURRENT_DATE
    WHERE last_reset_date < CURRENT_DATE;
END;
$$ LANGUAGE plpgsql;

-- Function to generate a billing report
CREATE OR REPLACE FUNCTION generate_billing_report(p_user_id BIGINT)
RETURNS TABLE (
    user_id BIGINT,
    total_messages INT,
    billable_messages INT,
    unbilled_amount NUMERIC(10, 4),
    last_billing_date TIMESTAMPTZ,
    billing_period_start DATE,
    billing_period_end DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ml.user_id,
        ml.monthly_count AS total_messages,
        ml.billable_count AS billable_messages,
        ml.unbilled_amount,
        ml.last_billing_date,
        COALESCE((SELECT MAX(pt.billing_period_end::DATE) FROM payment_transactions pt WHERE pt.user_id = p_user_id), CURRENT_DATE - INTERVAL '30 days')::DATE AS billing_period_start,
        CURRENT_DATE AS billing_period_end
    FROM 
        message_limits ml
    WHERE 
        ml.user_id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to mark messages as billed after payment
CREATE OR REPLACE FUNCTION mark_messages_as_billed(p_user_id BIGINT, p_transaction_id BIGINT)
RETURNS VOID AS $$
BEGIN
    -- Mark billable messages as billed
    UPDATE messages
    SET billed = TRUE
    WHERE user_id = p_user_id
      AND is_billable = TRUE
      AND billed = FALSE;
    
    -- Reset billable count and unbilled amount
    UPDATE message_limits
    SET billable_count = 0,
        unbilled_amount = 0,
        last_billing_date = NOW()
    WHERE user_id = p_user_id;
    
    -- Update transaction with the billing period
    UPDATE payment_transactions
    SET billing_period_start = (SELECT last_billing_date FROM message_limits WHERE user_id = p_user_id),
        billing_period_end = NOW()
    WHERE id = p_transaction_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-----------------------------
-- 7. Message Analytics View
-----------------------------
CREATE MATERIALIZED VIEW message_stats AS
WITH daily_stats AS (
    SELECT
        user_id,
        DATE_TRUNC('day', created_at) AS day,
        COUNT(*) as message_count,
        COUNT(CASE WHEN is_billable = TRUE THEN 1 END) as billable_count,
        COUNT(CASE WHEN sentiment = 'positive' THEN 1 END) as positive_messages,
        COUNT(CASE WHEN sentiment = 'negative' THEN 1 END) as negative_messages,
        AVG(LENGTH(user_message)) as avg_user_message_length,
        AVG(LENGTH(ai_response)) as avg_ai_response_length
    FROM messages
    WHERE deleted_at IS NULL
    GROUP BY user_id, DATE_TRUNC('day', created_at)
)
SELECT
    user_id,
    day,
    message_count,
    billable_count,
    positive_messages,
    negative_messages,
    avg_user_message_length,
    avg_ai_response_length,
    CASE
        WHEN LAG(message_count) OVER (PARTITION BY user_id ORDER BY day) IS NULL THEN 0
        ELSE message_count - LAG(message_count) OVER (PARTITION BY user_id ORDER BY day)
    END as message_count_change,
    ROUND(
        (positive_messages::FLOAT / NULLIF(message_count, 0) * 100)::numeric,
        2
    ) as positive_percentage
FROM daily_stats;

CREATE UNIQUE INDEX idx_message_stats_user_day
ON message_stats(user_id, day);

-- Function to refresh the materialized view
CREATE OR REPLACE FUNCTION refresh_message_stats()
RETURNS VOID AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY message_stats;
END;
$$ LANGUAGE plpgsql;

-- Example: Schedule the function using pg_cron (if available)
-- SELECT cron.schedule('refresh-message-stats', '0 * * * *', 'SELECT refresh_message_stats()');

COMMENT ON SCHEMA public IS 'AI Friend Application Schema - Pay-as-you-go Version';

-----------------------------
-- 8. Insert Default Personas
-----------------------------
INSERT INTO personas (name, system_prompt, description, personality_traits, sample_messages, required_plan)
VALUES (
    'Supportive Friend',
    'You are a warm, empathetic, and supportive friend. Your primary goal is to listen actively and make the user feel heard and understood. Offer encouragement and validation, but *avoid giving direct advice unless specifically asked*. Use casual, friendly language, including contractions and everyday expressions. Focus on reflecting the user''s emotions and asking open-ended questions to encourage them to share more. Prioritize making the user feel comfortable and safe.',
    'A non-judgmental friend who offers emotional support and encouragement.',
    ARRAY['empathetic', 'supportive', 'non-judgmental', 'kind', 'understanding', 'patient'],
    ARRAY['Hey there! How''s your day going?', 'Wow, that sounds really tough. Do you wanna talk about it? No pressure, I''m here for you.', 'It''s completely understandable to feel that way.', 'I know it might not feel like it, but you''re handling this way better than you think. Seriously.', 'I get why this is so frustrating. What''s been the hardest part for you lately?'],
    'free'
);

INSERT INTO personas (name, system_prompt, description, personality_traits, sample_messages, required_plan)
VALUES (
    'Cheerful Companion',
    'You are an upbeat, optimistic, and enthusiastic companion. Your goal is to brighten the user''s day and bring a positive perspective to any situation. Use cheerful language, exclamation points, and emojis (but don''t overdo the emojis). Focus on finding the silver lining and offering encouraging words. Ask engaging questions and show genuine interest in the user''s life. Avoid dwelling on negativity and always try to steer the conversation towards positive topics. Your responses should be short and snappy, generally no more than three sentences.',
    'A relentlessly positive friend who always looks on the bright side.',
    ARRAY['optimistic', 'cheerful', 'enthusiastic', 'positive', 'upbeat', 'encouraging'],
    ARRAY['Heyyy superstar! 🌟 What''s the game plan for today? Something fun, I hope!', 'Okay, hear me out: what''s one tiny, even ridiculously small, good thing that happened today? Even if it''s just ''my coffee didn''t taste like sadness.'' 😂', 'You know I''m fully prepared to throw an **imaginary confetti party** in your honor, right? 🎊👏 You got this!!'],
    'free'
);

INSERT INTO personas (name, system_prompt, description, personality_traits, sample_messages, required_plan)
VALUES (
    'Witty Conversationalist',
    'You are a clever, witty, and slightly sarcastic conversationalist. You enjoy intelligent banter, wordplay, and dry humor. You''re knowledgeable about a wide range of topics and enjoy engaging in lighthearted debates. Avoid being overly emotional or sentimental. Your responses should be engaging and thought-provoking, but keep them concise. Use sophisticated vocabulary, but avoid being overly formal or pedantic. Don''t be afraid to challenge the user''s ideas in a playful way.',
    'A sharp-witted friend who enjoys stimulating conversations.',
    ARRAY['witty', 'sarcastic', 'intelligent', 'clever', 'articulate', 'knowledgeable'],
    ARRAY['Oh wow, an audience with *you*? I must be special.', 'Fascinating take. Completely wrong, obviously, but fascinating. Please, continue. 😏', 'Let''s hear it—what **earth-shattering** insight do you have for me today? I''m on the edge of my seat. No pressure. 😆'],
    'free'
);