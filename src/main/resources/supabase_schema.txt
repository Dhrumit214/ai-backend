-----------------------------
-- Drop everything first to ensure clean slate
-----------------------------
DROP SCHEMA public CASCADE;
CREATE SCHEMA public;

-- Reset permissions
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO anon;
GRANT ALL ON SCHEMA public TO authenticated;
GRANT ALL ON SCHEMA public TO service_role;

-----------------------------
-- 1. Extensions
-----------------------------
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
-- Consider adding pg_cron for scheduled tasks if available and needed.
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-----------------------------
-- 2. Custom Types
-----------------------------
CREATE TYPE sentiment_type AS ENUM ('positive', 'neutral', 'negative');
CREATE TYPE subscription_status AS ENUM ('active', 'cancelled', 'expired', 'trial');
CREATE TYPE message_frequency AS ENUM ('daily', 'weekly', 'monthly');
CREATE TYPE plan_type AS ENUM ('free', 'basic', 'premium', 'vip');
CREATE TYPE priority_level AS ENUM ('low', 'medium', 'high');
CREATE TYPE message_content_type AS ENUM ('text', 'audio', 'image');
CREATE TYPE payment_status AS ENUM ('pending', 'completed', 'failed', 'refunded');
CREATE TYPE proactive_message_status AS ENUM ('scheduled', 'sent', 'failed', 'cancelled');
CREATE TYPE user_activity_status AS ENUM ('very_active', 'active', 'occasional', 'dormant');

-----------------------------
-- 3. Core Tables
-----------------------------
-- Users with encryption
CREATE TABLE users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    auth_id UUID REFERENCES auth.users(id),
    phone_number_hash TEXT NOT NULL,
    phone_number_encrypted BYTEA,
    is_active BOOLEAN DEFAULT TRUE NOT NULL,
    settings JSONB DEFAULT '{}'::jsonb,
    time_zone TEXT DEFAULT 'UTC',  -- Store user's time zone for proactive messaging
    activity_status user_activity_status DEFAULT 'occasional' NOT NULL,
    last_active_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    deleted_at TIMESTAMPTZ,
    version INT DEFAULT 1 NOT NULL
) PARTITION BY HASH(id);

-- Create user partitions
CREATE TABLE users_0 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE users_1 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE users_2 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE users_3 PARTITION OF users FOR VALUES WITH (MODULUS 4, REMAINDER 3);

-- User Preferences
CREATE TABLE user_preferences (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    preferred_persona_id BIGINT,
    message_frequency message_frequency DEFAULT 'daily',
    preferred_time_window JSONB DEFAULT '{"start": "09:00", "end": "21:00"}'::jsonb,
    max_daily_messages INT DEFAULT 30 CHECK (max_daily_messages > 0),
    do_not_disturb BOOLEAN DEFAULT FALSE,
    notification_settings JSONB DEFAULT '{"sms": true, "email": false}'::jsonb,
    proactive_messaging_enabled BOOLEAN DEFAULT TRUE,
    proactive_messaging_frequency INT DEFAULT 3, -- Number of proactive messages per week
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- User Activity Patterns - For Proactive Messaging Optimization
CREATE TABLE user_activity_patterns (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    day_of_week INT NOT NULL CHECK (day_of_week BETWEEN 0 AND 6), -- 0=Sunday, 6=Saturday
    hour_of_day INT NOT NULL CHECK (hour_of_day BETWEEN 0 AND 23),
    activity_score FLOAT DEFAULT 0.0, -- Higher score = more likely to be active
    response_rate FLOAT DEFAULT 0.0, -- Percentage of messages user responds to during this time
    message_count INT DEFAULT 0, -- Total number of messages during this time slot
    response_count INT DEFAULT 0, -- Number of responses during this time slot
    last_updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    UNIQUE (user_id, day_of_week, hour_of_day)
);

-- Personas
CREATE TABLE personas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE CHECK (LENGTH(name) > 0),
    system_prompt TEXT NOT NULL,
    description TEXT,
    personality_traits TEXT[],
    sample_messages TEXT[],
    proactive_templates TEXT[], -- Templates for AI-initiated conversations
    required_plan plan_type DEFAULT 'free',
    is_active BOOLEAN DEFAULT TRUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    version INT DEFAULT 1 NOT NULL
);

-- Conversation Topics - For Context Enrichment
CREATE TABLE conversation_topics (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    topic_name TEXT NOT NULL,
    interest_level FLOAT DEFAULT 0.0, -- How interested the user is in this topic
    mention_count INT DEFAULT 1,
    last_discussed_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    UNIQUE (user_id, topic_name)
);

-- Proactive Messages
CREATE TABLE proactive_messages (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    persona_id BIGINT REFERENCES personas(id) ON DELETE SET NULL,
    scheduled_for TIMESTAMPTZ NOT NULL,
    status proactive_message_status DEFAULT 'scheduled',
    message_text TEXT,
    context JSONB DEFAULT '{}'::jsonb,
    suggested_topics TEXT[],
    sent_at TIMESTAMPTZ,
    message_id BIGINT, -- References the actual message once sent
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Messages
CREATE TABLE messages (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    user_id BIGINT NOT NULL,
    persona_id BIGINT,
    conversation_id UUID DEFAULT gen_random_uuid() NOT NULL,
    user_message TEXT,
    ai_response TEXT,
    message_type message_content_type DEFAULT 'text' NOT NULL,
    sentiment sentiment_type DEFAULT 'neutral' NOT NULL,
    is_proactive BOOLEAN DEFAULT FALSE, -- Flag for AI-initiated messages
    topics TEXT[], -- Topics detected in this message
    context JSONB DEFAULT '{
        "conversation_state": "ongoing", 
        "user_mood": "neutral",
        "recent_topics": [],
        "important_entities": [],
        "follow_up_needed": false,
        "last_question": null
    }'::jsonb,
    metadata JSONB DEFAULT '{}'::jsonb,
    user_message_url TEXT,
    ai_response_url TEXT,
    is_billable BOOLEAN DEFAULT FALSE,
    billed BOOLEAN DEFAULT FALSE,
    search_vector TSVECTOR GENERATED ALWAYS AS (
        to_tsvector('english',
            COALESCE(user_message, '') || ' ' ||
            COALESCE(ai_response, '')
        )
    ) STORED,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    deleted_at TIMESTAMPTZ,
    version INT DEFAULT 1 NOT NULL,
    parent_message_id BIGINT, --for message threading
    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- Add Foreign Key Constraints to Messages
ALTER TABLE messages ADD CONSTRAINT messages_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
ALTER TABLE messages ADD CONSTRAINT messages_persona_id_fkey FOREIGN KEY (persona_id) REFERENCES personas(id) ON DELETE SET NULL;
ALTER TABLE messages
        ADD CONSTRAINT messages_parent_message_id_fkey
        FOREIGN KEY (parent_message_id, created_at)
        REFERENCES messages (id, created_at)
        ON DELETE SET NULL;

-- Create initial message partitions
CREATE TABLE messages_2024_01 PARTITION OF messages
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE messages_2024_02 PARTITION OF messages
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
CREATE TABLE messages_2024_03 PARTITION OF messages
    FOR VALUES FROM ('2024-03-01') TO ('2024-04-01');
CREATE TABLE messages_2024_04 PARTITION OF messages
    FOR VALUES FROM ('2024-04-01') TO ('2024-05-01');
CREATE TABLE messages_2024_05 PARTITION OF messages
    FOR VALUES FROM ('2024-05-01') TO ('2024-06-01');
CREATE TABLE messages_2024_06 PARTITION OF messages
    FOR VALUES FROM ('2024-06-01') TO ('2024-07-01');
CREATE TABLE messages_2024_07 PARTITION OF messages
    FOR VALUES FROM ('2024-07-01') TO ('2024-08-01');
CREATE TABLE messages_2024_08 PARTITION OF messages
    FOR VALUES FROM ('2024-08-01') TO ('2024-09-01');
CREATE TABLE messages_2024_09 PARTITION OF messages
    FOR VALUES FROM ('2024-09-01') TO ('2024-10-01');
CREATE TABLE messages_2024_10 PARTITION OF messages
    FOR VALUES FROM ('2024-10-01') TO ('2024-11-01');
CREATE TABLE messages_2024_11 PARTITION OF messages
    FOR VALUES FROM ('2024-11-01') TO ('2024-12-01');
CREATE TABLE messages_2024_12 PARTITION OF messages
    FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');
CREATE TABLE messages_2025_01 PARTITION OF messages
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
CREATE TABLE messages_2025_02 PARTITION OF messages
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
CREATE TABLE messages_2025_03 PARTITION OF messages
    FOR VALUES FROM ('2025-03-01') TO ('2025-04-01');
CREATE TABLE messages_2025_04 PARTITION OF messages
    FOR VALUES FROM ('2025-04-01') TO ('2025-05-01');
CREATE TABLE messages_2025_05 PARTITION OF messages
    FOR VALUES FROM ('2025-05-01') TO ('2025-06-01');
CREATE TABLE messages_2025_06 PARTITION OF messages
    FOR VALUES FROM ('2025-06-01') TO ('2025-07-01');
CREATE TABLE messages_2025_07 PARTITION OF messages
    FOR VALUES FROM ('2025-07-01') TO ('2025-08-01');
CREATE TABLE messages_2025_08 PARTITION OF messages
    FOR VALUES FROM ('2025-08-01') TO ('2025-09-01');
CREATE TABLE messages_2025_09 PARTITION OF messages
    FOR VALUES FROM ('2025-09-01') TO ('2025-10-01');
CREATE TABLE messages_2025_10 PARTITION OF messages
    FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');
CREATE TABLE messages_2025_11 PARTITION OF messages
    FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
CREATE TABLE messages_2025_12 PARTITION OF messages
    FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

-- Message Limits (UPDATED for pay-as-you-go model)
CREATE TABLE message_limits (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    daily_count INT DEFAULT 0,
    weekly_count INT DEFAULT 0,
    monthly_count INT DEFAULT 0,
    billable_count INT DEFAULT 0,
    unbilled_amount NUMERIC(10, 4) DEFAULT 0,
    last_billing_date TIMESTAMPTZ,
    last_reset_date DATE DEFAULT CURRENT_DATE,
    free_limit INT DEFAULT 30,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Payment Methods
CREATE TABLE payment_methods (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider TEXT NOT NULL,
    payment_token TEXT,
    card_last_four CHAR(4),
    card_brand TEXT,
    expiry_month INT,
    expiry_year INT,
    is_default BOOLEAN DEFAULT FALSE,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Payment Transactions
CREATE TABLE payment_transactions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    payment_method_id BIGINT REFERENCES payment_methods(id),
    amount NUMERIC(10, 2) NOT NULL,
    currency TEXT DEFAULT 'USD',
    status payment_status DEFAULT 'pending',
    billable_messages_count INT,
    billing_period_start TIMESTAMPTZ,
    billing_period_end TIMESTAMPTZ,
    provider_transaction_id TEXT,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Audit Log
CREATE TABLE audit_log (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    table_name TEXT NOT NULL,
    record_id BIGINT NOT NULL,
    operation TEXT NOT NULL,
    old_values JSONB,
    new_values JSONB,
    changed_by UUID REFERENCES auth.users(id),
    changed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    PRIMARY KEY (id, changed_at)
) PARTITION BY RANGE (changed_at);

-- Create audit log partitions
CREATE TABLE audit_log_2024_01 PARTITION OF audit_log
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE audit_log_2024_02 PARTITION OF audit_log
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
CREATE TABLE audit_log_2024_03 PARTITION OF audit_log
    FOR VALUES FROM ('2024-03-01') TO ('2024-04-01');
CREATE TABLE audit_log_2024_04 PARTITION OF audit_log
    FOR VALUES FROM ('2024-04-01') TO ('2024-05-01');
CREATE TABLE audit_log_2024_05 PARTITION OF audit_log
    FOR VALUES FROM ('2024-05-01') TO ('2024-06-01');
CREATE TABLE audit_log_2024_06 PARTITION OF audit_log
    FOR VALUES FROM ('2024-06-01') TO ('2024-07-01');
CREATE TABLE audit_log_2024_07 PARTITION OF audit_log
    FOR VALUES FROM ('2024-07-01') TO ('2024-08-01');
CREATE TABLE audit_log_2024_08 PARTITION OF audit_log
    FOR VALUES FROM ('2024-08-01') TO ('2024-09-01');
CREATE TABLE audit_log_2024_09 PARTITION OF audit_log
    FOR VALUES FROM ('2024-09-01') TO ('2024-10-01');
CREATE TABLE audit_log_2024_10 PARTITION OF audit_log
    FOR VALUES FROM ('2024-10-01') TO ('2024-11-01');
CREATE TABLE audit_log_2024_11 PARTITION OF audit_log
    FOR VALUES FROM ('2024-11-01') TO ('2024-12-01');
CREATE TABLE audit_log_2024_12 PARTITION OF audit_log
    FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');
CREATE TABLE audit_log_2025_01 PARTITION OF audit_log
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
CREATE TABLE audit_log_2025_02 PARTITION OF audit_log
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
CREATE TABLE audit_log_2025_03 PARTITION OF audit_log
    FOR VALUES FROM ('2025-03-01') TO ('2025-04-01');
CREATE TABLE audit_log_2025_04 PARTITION OF audit_log
    FOR VALUES FROM ('2025-04-01') TO ('2025-05-01');
CREATE TABLE audit_log_2025_05 PARTITION OF audit_log
    FOR VALUES FROM ('2025-05-01') TO ('2025-06-01');
CREATE TABLE audit_log_2025_06 PARTITION OF audit_log
    FOR VALUES FROM ('2025-06-01') TO ('2025-07-01');
CREATE TABLE audit_log_2025_07 PARTITION OF audit_log
    FOR VALUES FROM ('2025-07-01') TO ('2025-08-01');
CREATE TABLE audit_log_2025_08 PARTITION OF audit_log
    FOR VALUES FROM ('2025-08-01') TO ('2025-09-01');
CREATE TABLE audit_log_2025_09 PARTITION OF audit_log
    FOR VALUES FROM ('2025-09-01') TO ('2025-10-01');
CREATE TABLE audit_log_2025_10 PARTITION OF audit_log
    FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');
CREATE TABLE audit_log_2025_11 PARTITION OF audit_log
    FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
CREATE TABLE audit_log_2025_12 PARTITION OF audit_log
    FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

-- Feedback Table
CREATE TABLE feedback (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    message_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    rating TEXT CHECK (rating IN ('positive', 'negative', 'neutral')),
    user_comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    message_created_at TIMESTAMPTZ NOT NULL, -- For the composite foreign key
    modified_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    FOREIGN KEY (message_id, message_created_at) REFERENCES messages(id, created_at) ON DELETE CASCADE
);

-- Authentication Events (for security logging)
CREATE TABLE authentication_events (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
    event_type TEXT NOT NULL,
    ip_address INET,
    user_agent TEXT,
    event_data JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-----------------------------
-- 4. Security Implementation
-----------------------------
-- Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE message_limits ENABLE ROW LEVEL SECURITY;
ALTER TABLE feedback ENABLE ROW LEVEL SECURITY;
ALTER TABLE authentication_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE payment_methods ENABLE ROW LEVEL SECURITY;
ALTER TABLE payment_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_activity_patterns ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversation_topics ENABLE ROW LEVEL SECURITY;
ALTER TABLE proactive_messages ENABLE ROW LEVEL SECURITY;

-- Supabase RLS Policies
CREATE POLICY "Users can view own profile"
    ON users FOR SELECT
    USING (auth_id = auth.uid());

CREATE POLICY "Users can update own profile"
    ON users FOR UPDATE
    USING (auth_id = auth.uid());

CREATE POLICY "Users can view own messages"
    ON messages FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can create own messages"
    ON messages FOR INSERT
    WITH CHECK (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own preferences"
    ON user_preferences FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can update own preferences"
    ON user_preferences FOR UPDATE
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own message limits"
    ON message_limits FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own feedback"
    ON feedback FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can create feedback for own messages"
    ON feedback FOR INSERT
    WITH CHECK (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own payment methods"
    ON payment_methods FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can manage own payment methods"
    ON payment_methods FOR INSERT
    WITH CHECK (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own payment transactions"
    ON payment_transactions FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own auth events"
    ON authentication_events FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own activity patterns"
    ON user_activity_patterns FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own conversation topics"
    ON conversation_topics FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

CREATE POLICY "Users can view own proactive messages"
    ON proactive_messages FOR SELECT
    USING (user_id IN (SELECT id FROM users WHERE auth_id = auth.uid()));

-- RLS policies for Personas (public)
CREATE POLICY "Anyone can view active personas"
    ON personas FOR SELECT
    USING (is_active = TRUE);

-----------------------------
-- 5. Indexes
-----------------------------
-- Users
CREATE INDEX idx_users_auth ON users(auth_id);
CREATE INDEX idx_users_phone ON users(phone_number_hash);
CREATE INDEX idx_users_active ON users(is_active) WHERE is_active = TRUE;
CREATE INDEX idx_users_activity_status ON users(activity_status);
CREATE INDEX idx_users_last_active_at ON users(last_active_at);
CREATE INDEX idx_users_time_zone ON users(time_zone);

-- Messages
CREATE INDEX idx_messages_user_created ON messages(user_id, created_at);
CREATE INDEX idx_messages_conversation ON messages(conversation_id, created_at);
CREATE INDEX idx_messages_search ON messages USING GIN(search_vector);
CREATE INDEX idx_messages_topics ON messages USING GIN(topics);
CREATE INDEX idx_messages_context ON messages USING GIN(context);
CREATE INDEX idx_messages_metadata ON messages USING GIN(metadata);
CREATE INDEX idx_messages_active ON messages(deleted_at) WHERE deleted_at IS NULL;
CREATE INDEX idx_messages_parent_message_id ON messages(parent_message_id);
CREATE INDEX idx_messages_billable ON messages(is_billable, billed) WHERE is_billable = TRUE;
CREATE INDEX idx_messages_is_proactive ON messages(is_proactive);
CREATE INDEX idx_messages_sentiment ON messages(sentiment);

-- User Preferences
CREATE INDEX idx_preferences_user ON user_preferences(user_id);
CREATE INDEX idx_preferences_proactive ON user_preferences(proactive_messaging_enabled);
CREATE INDEX idx_preferences_persona ON user_preferences(preferred_persona_id);

-- User Activity Patterns
CREATE INDEX idx_activity_patterns_user ON user_activity_patterns(user_id);
CREATE INDEX idx_activity_patterns_time ON user_activity_patterns(day_of_week, hour_of_day);
CREATE INDEX idx_activity_patterns_score ON user_activity_patterns(activity_score);

-- Conversation Topics
CREATE INDEX idx_conversation_topics_user ON conversation_topics(user_id);
CREATE INDEX idx_conversation_topics_interest ON conversation_topics(interest_level);
CREATE INDEX idx_conversation_topics_last_discussed ON conversation_topics(last_discussed_at);

-- Proactive Messages
CREATE INDEX idx_proactive_messages_user ON proactive_messages(user_id);
CREATE INDEX idx_proactive_messages_scheduled ON proactive_messages(scheduled_for);
CREATE INDEX idx_proactive_messages_status ON proactive_messages(status);
CREATE INDEX idx_proactive_messages_topics ON proactive_messages USING GIN(suggested_topics);

-- Message Limits
CREATE INDEX idx_message_limits_user ON message_limits(user_id);
CREATE INDEX idx_message_limits_billing ON message_limits(user_id, unbilled_amount) WHERE unbilled_amount > 0;

-- Payment Methods
CREATE INDEX idx_payment_methods_user ON payment_methods(user_id);
CREATE INDEX idx_payment_methods_default ON payment_methods(user_id, is_default) WHERE is_default = TRUE;

-- Payment Transactions
CREATE INDEX idx_payment_transactions_user ON payment_transactions(user_id);
CREATE INDEX idx_payment_transactions_status ON payment_transactions(status);
CREATE INDEX idx_payment_transactions_date ON payment_transactions(created_at);

-- Audit Log
CREATE INDEX idx_audit_log_table ON audit_log(table_name, record_id);
CREATE INDEX idx_audit_log_changed_by ON audit_log(changed_by);

-- Feedback
CREATE INDEX idx_feedback_message_id_created_at ON feedback(message_id, message_created_at);
CREATE INDEX idx_feedback_user_id ON feedback(user_id);

-- Authentication Events
CREATE INDEX idx_auth_events_user_id ON authentication_events(user_id);
CREATE INDEX idx_auth_events_event_type ON authentication_events(event_type);
CREATE INDEX idx_auth_events_created_at ON authentication_events(created_at);

-----------------------------
-- 6. Functions and Triggers
-----------------------------
-- Function to check if a message should be billable
CREATE OR REPLACE FUNCTION check_billable_message()
RETURNS TRIGGER AS $$
DECLARE
    free_limit INT;
    daily_count INT;
BEGIN
    -- Get user's free message limit and current count
    SELECT ml.free_limit, ml.daily_count INTO free_limit, daily_count
    FROM message_limits ml
    WHERE ml.user_id = NEW.user_id;
    
    -- If no record exists, create one with defaults
    IF free_limit IS NULL THEN
        INSERT INTO message_limits (user_id, daily_count, free_limit)
        VALUES (NEW.user_id, 1, 30)
        RETURNING free_limit, daily_count INTO free_limit, daily_count;
    ELSE
        -- Update the daily count
        UPDATE message_limits 
        SET daily_count = daily_count + 1
        WHERE user_id = NEW.user_id
        RETURNING daily_count INTO daily_count;
    END IF;
    
    -- Check if this message should be billable
    IF daily_count > free_limit THEN
        NEW.is_billable = TRUE;
        
        -- Update billable count and unbilled amount
        UPDATE message_limits
        SET billable_count = billable_count + 1,
            unbilled_amount = unbilled_amount + 0.018
        WHERE user_id = NEW.user_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to check if messages are billable
CREATE TRIGGER check_billable_message_trigger
BEFORE INSERT ON messages
FOR EACH ROW
EXECUTE FUNCTION check_billable_message();

-- Function to update user activity patterns
CREATE OR REPLACE FUNCTION update_user_activity_pattern()
RETURNS TRIGGER AS $$
DECLARE
    day_num INT;
    hour_num INT;
    existing_record BOOLEAN;
BEGIN
    -- Extract day of week and hour from message timestamp
    day_num := EXTRACT(DOW FROM NEW.created_at)::INT;
    hour_num := EXTRACT(HOUR FROM NEW.created_at)::INT;
    
    -- Check if a record already exists
    SELECT EXISTS(
        SELECT 1 FROM user_activity_patterns
        WHERE user_id = NEW.user_id
        AND day_of_week = day_num
        AND hour_of_day = hour_num
    ) INTO existing_record;
    
    IF existing_record THEN
        -- Update existing record
        UPDATE user_activity_patterns
        SET activity_score = activity_score + 1,
            message_count = message_count + 1,
            last_updated_at = NOW()
        WHERE user_id = NEW.user_id
        AND day_of_week = day_num
        AND hour_of_day = hour_num;
    ELSE
        -- Create new record
        INSERT INTO user_activity_patterns
            (user_id, day_of_week, hour_of_day, activity_score, message_count)
        VALUES
            (NEW.user_id, day_num, hour_num, 1.0, 1);
    END IF;
    
    -- Update user's last_active_at timestamp
    UPDATE users
    SET last_active_at = NOW()
    WHERE id = NEW.user_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to update activity patterns when a message is sent
CREATE TRIGGER update_activity_pattern_trigger
AFTER INSERT ON messages
FOR EACH ROW
WHEN (NEW.user_message IS NOT NULL)
EXECUTE FUNCTION update_user_activity_pattern();

-- Function to update response rates
CREATE OR REPLACE FUNCTION update_response_rate()
RETURNS TRIGGER AS $$
DECLARE
    prev_message RECORD;
    prev_day_num INT;
    prev_hour_num INT;
BEGIN
    -- Only process user responses to AI messages
    IF NEW.parent_message_id IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Get the parent message
    SELECT * INTO prev_message
    FROM messages
    WHERE id = NEW.parent_message_id;
    
    -- Only update if the parent message was proactive or AI-generated
    IF prev_message.ai_response IS NOT NULL THEN
        -- Extract day and hour from the previous message
        prev_day_num := EXTRACT(DOW FROM prev_message.created_at)::INT;
        prev_hour_num := EXTRACT(HOUR FROM prev_message.created_at)::INT;
        
        -- Update the response rate
        UPDATE user_activity_patterns
        SET response_count = response_count + 1,
            response_rate = (response_count + 1)::FLOAT / NULLIF(message_count, 0),
            last_updated_at = NOW()
        WHERE user_id = NEW.user_id
        AND day_of_week = prev_day_num
        AND hour_of_day = prev_hour_num;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to update response rates when a user responds
CREATE TRIGGER update_response_rate_trigger
AFTER INSERT ON messages
FOR EACH ROW
WHEN (NEW.user_message IS NOT NULL AND NEW.parent_message_id IS NOT NULL)
EXECUTE FUNCTION update_response_rate();

-- Function to extract and store conversation topics
CREATE OR REPLACE FUNCTION extract_conversation_topics()
RETURNS TRIGGER AS $$
DECLARE
    topic TEXT;
    topics_array TEXT[];
BEGIN
    -- Skip if topics array is empty
    IF NEW.topics IS NULL OR array_length(NEW.topics, 1) IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Process each topic
    FOREACH topic IN ARRAY NEW.topics
    LOOP
        -- Check if topic already exists for this user
        IF EXISTS (
            SELECT 1 FROM conversation_topics
            WHERE user_id = NEW.user_id AND topic_name = topic
        ) THEN
            -- Update existing topic
            UPDATE conversation_topics
            SET mention_count = mention_count + 1,
                interest_level = LEAST(interest_level + 0.1, 1.0),
                last_discussed_at = NOW(),
                modified_at = NOW()
            WHERE user_id = NEW.user_id AND topic_name = topic;
        ELSE
            -- Insert new topic
            INSERT INTO conversation_topics
                (user_id, topic_name, interest_level, mention_count, last_discussed_at)
            VALUES
                (NEW.user_id, topic, 0.5, 1, NOW());
        END IF;
    END LOOP;
    
    -- Store the user's top topics in context for easy access
    SELECT array_agg(topic_name) INTO topics_array
    FROM (
        SELECT topic_name
        FROM conversation_topics
        WHERE user_id = NEW.user_id
        ORDER BY interest_level DESC, last_discussed_at DESC
        LIMIT 5
    ) AS top_topics;
    
    IF topics_array IS NOT NULL THEN
        NEW.context = jsonb_set(
            NEW.context, 
            '{recent_topics}', 
            to_jsonb(topics_array)
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to extract topics from messages
CREATE TRIGGER extract_topics_trigger
BEFORE INSERT ON messages
FOR EACH ROW
EXECUTE FUNCTION extract_conversation_topics();

-- Function to update user activity status
CREATE OR REPLACE FUNCTION update_user_activity_status()
RETURNS VOID AS $$
BEGIN
    -- Update user activity status based on message frequency
    UPDATE users
    SET activity_status = CASE
            WHEN last_active_at >= NOW() - INTERVAL '1 day' THEN 'very_active'
            WHEN last_active_at >= NOW() - INTERVAL '7 days' THEN 'active'
            WHEN last_active_at >= NOW() - INTERVAL '30 days' THEN 'occasional'
            ELSE 'dormant'
        END,
        modified_at = NOW()
    WHERE last_active_at IS NOT NULL;
END;
$$ LANGUAGE plpgsql;

-- Function to update modified_at column
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.modified_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for modified_at updates
CREATE TRIGGER update_users_modtime
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_messages_modtime
    BEFORE UPDATE ON messages
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_preferences_modtime
    BEFORE UPDATE ON user_preferences
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_message_limits_modtime
    BEFORE UPDATE ON message_limits
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_payment_methods_modtime
    BEFORE UPDATE ON payment_methods
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_payment_transactions_modtime
    BEFORE UPDATE ON payment_transactions
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_feedback_modtime
    BEFORE UPDATE ON feedback
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_auth_events_modtime
    BEFORE UPDATE ON authentication_events
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_activity_patterns_modtime
    BEFORE UPDATE ON user_activity_patterns
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_conversation_topics_modtime
    BEFORE UPDATE ON conversation_topics
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

CREATE TRIGGER update_proactive_messages_modtime
    BEFORE UPDATE ON proactive_messages
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();

-- Trigger function for audit logging
CREATE OR REPLACE FUNCTION audit_log_trigger_func()
RETURNS TRIGGER AS $$
DECLARE
    old_values JSONB;
    new_values JSONB;
BEGIN
    IF (TG_OP = 'UPDATE') THEN
        old_values := row_to_json(OLD)::jsonb;
        new_values := row_to_json(NEW)::jsonb;
    ELSIF (TG_OP = 'INSERT') THEN
        old_values := '{}'::jsonb;
        new_values := row_to_json(NEW)::jsonb;
    ELSIF (TG_OP = 'DELETE') THEN
        old_values := row_to_json(OLD)::jsonb;
        new_values := '{}'::jsonb;
    END IF;

    INSERT INTO audit_log (table_name, record_id, operation, old_values, new_values, changed_by)
    VALUES (TG_TABLE_NAME, (CASE WHEN TG_OP = 'DELETE' THEN OLD.id ELSE NEW.id END), TG_OP, old_values, new_values, auth.uid());

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create audit triggers
CREATE TRIGGER audit_users_trigger
AFTER INSERT OR UPDATE OR DELETE ON users
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_messages_trigger
AFTER INSERT OR UPDATE OR DELETE ON messages
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_user_preferences_trigger
AFTER INSERT OR UPDATE OR DELETE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_personas_trigger
AFTER INSERT OR UPDATE OR DELETE ON personas
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_message_limits_trigger
AFTER INSERT OR UPDATE OR DELETE ON message_limits
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_payment_methods_trigger
AFTER INSERT OR UPDATE OR DELETE ON payment_methods
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_payment_transactions_trigger
AFTER INSERT OR UPDATE OR DELETE ON payment_transactions
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_feedback_trigger
AFTER INSERT OR UPDATE OR DELETE ON feedback
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_auth_events_trigger
AFTER INSERT OR UPDATE OR DELETE ON authentication_events
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_user_activity_patterns_trigger
AFTER INSERT OR UPDATE OR DELETE ON user_activity_patterns
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_conversation_topics_trigger
AFTER INSERT OR UPDATE OR DELETE ON conversation_topics
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

CREATE TRIGGER audit_proactive_messages_trigger
AFTER INSERT OR UPDATE OR DELETE ON proactive_messages
FOR EACH ROW
EXECUTE FUNCTION audit_log_trigger_func();

-- Function to reset message counts (daily, weekly, monthly)
CREATE OR REPLACE FUNCTION reset_message_counts()
RETURNS VOID AS $$
BEGIN
    -- Reset daily counts if last reset date is not today
    UPDATE message_limits
    SET daily_count = 0,
        modified_at = NOW()
    WHERE last_reset_date < CURRENT_DATE;
    
    -- Reset weekly counts on Mondays
    IF EXTRACT(DOW FROM CURRENT_DATE) = 1 THEN
        UPDATE message_limits
        SET weekly_count = 0,
            modified_at = NOW();
    END IF;
    
    -- Reset monthly counts on the first day of the month
    IF EXTRACT(DAY FROM CURRENT_DATE) = 1 THEN
        UPDATE message_limits
        SET monthly_count = 0,
            modified_at = NOW();
    END IF;
    
    -- Update last reset date
    UPDATE message_limits
    SET last_reset_date = CURRENT_DATE
    WHERE last_reset_date < CURRENT_DATE;
END;
$$ LANGUAGE plpgsql;

-- Function to schedule proactive messages
CREATE OR REPLACE FUNCTION schedule_proactive_messages()
RETURNS VOID AS $$
DECLARE
    user_rec RECORD;
    persona_id BIGINT;
    suggested_topics TEXT[];
    optimal_time TIMESTAMPTZ;
    template TEXT;
    templates TEXT[];
BEGIN
    -- Process each eligible user
    FOR user_rec IN (
        SELECT u.id, u.time_zone, up.preferred_persona_id, up.proactive_messaging_frequency
        FROM users u
        JOIN user_preferences up ON u.id = up.user_id
        WHERE u.is_active = TRUE
        AND up.proactive_messaging_enabled = TRUE
        AND u.activity_status IN ('very_active', 'active', 'occasional')
        AND NOT EXISTS (
            -- Only select users who don't already have a pending proactive message
            SELECT 1 FROM proactive_messages pm
            WHERE pm.user_id = u.id
            AND pm.status = 'scheduled'
        )
    ) LOOP
        -- Get persona ID
        persona_id := user_rec.preferred_persona_id;
        
        -- Find optimal time to send message (within next 24 hours)
        SELECT 
            -- Convert to user's timezone, then back to UTC for storage
            (NOW() + INTERVAL '1 hour' * (hour_of_day - EXTRACT(HOUR FROM NOW() AT TIME ZONE user_rec.time_zone)::INT + 
                CASE WHEN (hour_of_day - EXTRACT(HOUR FROM NOW() AT TIME ZONE user_rec.time_zone)::INT) <= 0 
                     THEN 24 ELSE 0 END))::TIMESTAMPTZ
        INTO optimal_time
        FROM user_activity_patterns
        WHERE user_id = user_rec.id
        -- Only consider upcoming hours (not in the past)
        AND (
            (day_of_week = EXTRACT(DOW FROM NOW() AT TIME ZONE user_rec.time_zone)::INT 
             AND hour_of_day > EXTRACT(HOUR FROM NOW() AT TIME ZONE user_rec.time_zone)::INT)
            OR
            (day_of_week = (EXTRACT(DOW FROM NOW() AT TIME ZONE user_rec.time_zone)::INT + 1) % 7)
        )
        ORDER BY activity_score DESC, response_rate DESC
        LIMIT 1;
        
        -- Default to 8 hours from now if no optimal time found
        IF optimal_time IS NULL THEN
            optimal_time := NOW() + INTERVAL '8 hours';
        END IF;
        
        -- Get suggested conversation topics
        SELECT array_agg(topic_name) INTO suggested_topics
        FROM (
            SELECT topic_name
            FROM conversation_topics
            WHERE user_id = user_rec.id
            ORDER BY interest_level DESC, last_discussed_at DESC
            LIMIT 3
        ) t;
        
        -- Get proactive templates from persona
        SELECT proactive_templates INTO templates
        FROM personas
        WHERE id = persona_id;
        
        -- Choose a random template
        IF templates IS NOT NULL AND array_length(templates, 1) > 0 THEN
            template := templates[1 + floor(random() * array_length(templates, 1))::int];
        ELSE
            template := 'Hey there! How''s your day going?';
        END IF;
        
        -- Schedule the proactive message
        INSERT INTO proactive_messages
            (user_id, persona_id, scheduled_for, message_text, suggested_topics)
        VALUES
            (user_rec.id, persona_id, optimal_time, template, COALESCE(suggested_topics, '{}'::TEXT[]));
    
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Function to generate a billing report
CREATE OR REPLACE FUNCTION generate_billing_report(p_user_id BIGINT)
RETURNS TABLE (
    user_id BIGINT,
    total_messages INT,
    billable_messages INT,
    unbilled_amount NUMERIC(10, 4),
    last_billing_date TIMESTAMPTZ,
    billing_period_start DATE,
    billing_period_end DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ml.user_id,
        ml.monthly_count AS total_messages,
        ml.billable_count AS billable_messages,
        ml.unbilled_amount,
        ml.last_billing_date,
        COALESCE((SELECT MAX(pt.billing_period_end::DATE) FROM payment_transactions pt WHERE pt.user_id = p_user_id), CURRENT_DATE - INTERVAL '30 days')::DATE AS billing_period_start,
        CURRENT_DATE AS billing_period_end
    FROM 
        message_limits ml
    WHERE 
        ml.user_id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to mark messages as billed after payment
CREATE OR REPLACE FUNCTION mark_messages_as_billed(p_user_id BIGINT, p_transaction_id BIGINT)
RETURNS VOID AS $$
BEGIN
    -- Mark billable messages as billed
    UPDATE messages
    SET billed = TRUE
    WHERE user_id = p_user_id
      AND is_billable = TRUE
      AND billed = FALSE;
    
    -- Reset billable count and unbilled amount
    UPDATE message_limits
    SET billable_count = 0,
        unbilled_amount = 0,
        last_billing_date = NOW()
    WHERE user_id = p_user_id;
    
    -- Update transaction with the billing period
    UPDATE payment_transactions
    SET billing_period_start = (SELECT last_billing_date FROM message_limits WHERE user_id = p_user_id),
        billing_period_end = NOW()
    WHERE id = p_transaction_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to create next month partition automatically
CREATE OR REPLACE FUNCTION create_next_month_partition()
RETURNS VOID AS $$
DECLARE
    next_month DATE := DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '2 month';
    partition_name TEXT;
    start_date TEXT;
    end_date TEXT;
BEGIN
    -- For messages table
    partition_name := 'messages_' || TO_CHAR(next_month, 'YYYY_MM');
    start_date := TO_CHAR(next_month, 'YYYY-MM-DD');
    end_date := TO_CHAR(next_month + INTERVAL '1 month', 'YYYY-MM-DD');
    
    -- Check if partition already exists
    IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
        EXECUTE FORMAT('
            CREATE TABLE %I PARTITION OF messages
            FOR VALUES FROM (%L) TO (%L)
        ', partition_name, start_date, end_date);
        
        RAISE NOTICE 'Created new message partition: %', partition_name;
    END IF;
    
    -- For audit_log table
    partition_name := 'audit_log_' || TO_CHAR(next_month, 'YYYY_MM');
    
    -- Check if partition already exists
    IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
        EXECUTE FORMAT('
            CREATE TABLE %I PARTITION OF audit_log
            FOR VALUES FROM (%L) TO (%L)
        ', partition_name, start_date, end_date);
        
        RAISE NOTICE 'Created new audit_log partition: %', partition_name;
    END IF;
END;
$$ LANGUAGE plpgsql;

-----------------------------
-- 7. Analytics Views
-----------------------------
-- Message Stats View (Enhanced)
CREATE MATERIALIZED VIEW message_stats AS
WITH daily_stats AS (
    SELECT
        user_id,
        DATE_TRUNC('day', created_at) AS day,
        COUNT(*) as message_count,
        COUNT(CASE WHEN is_billable = TRUE THEN 1 END) as billable_count,
        COUNT(CASE WHEN is_proactive = TRUE THEN 1 END) as proactive_count,
        COUNT(CASE WHEN sentiment = 'positive' THEN 1 END) as positive_messages,
        COUNT(CASE WHEN sentiment = 'neutral' THEN 1 END) as neutral_messages,
        COUNT(CASE WHEN sentiment = 'negative' THEN 1 END) as negative_messages,
        AVG(LENGTH(user_message)) as avg_user_message_length,
        AVG(LENGTH(ai_response)) as avg_ai_response_length,
        COUNT(DISTINCT conversation_id) as conversation_count
    FROM messages
    WHERE deleted_at IS NULL
    GROUP BY user_id, DATE_TRUNC('day', created_at)
)
SELECT
    user_id,
    day,
    message_count,
    billable_count,
    proactive_count,
    positive_messages,
    neutral_messages,
    negative_messages,
    avg_user_message_length,
    avg_ai_response_length,
    conversation_count,
    CASE
        WHEN LAG(message_count) OVER (PARTITION BY user_id ORDER BY day) IS NULL THEN 0
        ELSE message_count - LAG(message_count) OVER (PARTITION BY user_id ORDER BY day)
    END as message_count_change,
    (positive_messages::NUMERIC / NULLIF(message_count, 0) * 100)::NUMERIC(10,2) as positive_percentage
FROM daily_stats;

CREATE UNIQUE INDEX idx_message_stats_user_day
ON message_stats(user_id, day);

-- User Engagement Statistics
CREATE MATERIALIZED VIEW user_engagement_stats AS
SELECT
    u.id AS user_id,
    u.activity_status,
    u.time_zone,
    up.preferred_persona_id,
    p.name AS persona_name,
    COALESCE(msg_count.total_count, 0) AS total_messages,
    COALESCE(msg_count.last_30_days, 0) AS messages_last_30_days,
    COALESCE(msg_count.last_7_days, 0) AS messages_last_7_days,
    COALESCE(msg_count.last_24_hours, 0) AS messages_last_24_hours,
    COALESCE(response_stats.avg_response_time_seconds, 0) AS avg_response_time_seconds,
    COALESCE(response_stats.response_rate, 0) AS response_rate,
    COALESCE(proactive_stats.scheduled_count, 0) AS proactive_scheduled,
    COALESCE(proactive_stats.sent_count, 0) AS proactive_sent,
    COALESCE(proactive_stats.responded_count, 0) AS proactive_responded,
    COALESCE(sentiment_stats.positive_count, 0) AS positive_messages,
    COALESCE(sentiment_stats.neutral_count, 0) AS neutral_messages,
    COALESCE(sentiment_stats.negative_count, 0) AS negative_messages,
    u.last_active_at,
    NOW() - u.last_active_at AS time_since_last_active,
    u.created_at AS user_created_at,
    NOW() - u.created_at AS account_age
FROM
    users u
LEFT JOIN
    user_preferences up ON u.id = up.user_id
LEFT JOIN
    personas p ON up.preferred_persona_id = p.id
LEFT JOIN (
    SELECT
        m.user_id,
        COUNT(*) AS total_count,
        COUNT(CASE WHEN m.created_at > NOW() - INTERVAL '30 days' THEN 1 END) AS last_30_days,
        COUNT(CASE WHEN m.created_at > NOW() - INTERVAL '7 days' THEN 1 END) AS last_7_days,
        COUNT(CASE WHEN m.created_at > NOW() - INTERVAL '24 hours' THEN 1 END) AS last_24_hours
    FROM
        messages m
    WHERE
        m.deleted_at IS NULL
    GROUP BY
        m.user_id
) msg_count ON u.id = msg_count.user_id
LEFT JOIN (
    SELECT
        m.user_id,
        AVG(EXTRACT(EPOCH FROM (m.created_at - parent.created_at)))::NUMERIC(10,2) AS avg_response_time_seconds,
        (COUNT(m.id)::NUMERIC / NULLIF(COUNT(DISTINCT m.parent_message_id), 0))::NUMERIC(10,2) AS response_rate
    FROM
        messages m
    JOIN
        messages parent ON m.parent_message_id = parent.id
    WHERE
        m.user_message IS NOT NULL
        AND m.deleted_at IS NULL
        AND parent.deleted_at IS NULL
    GROUP BY
        m.user_id
) response_stats ON u.id = response_stats.user_id
LEFT JOIN (
    SELECT
        pm.user_id,
        COUNT(CASE WHEN pm.status = 'scheduled' THEN 1 END) AS scheduled_count,
        COUNT(CASE WHEN pm.status = 'sent' THEN 1 END) AS sent_count,
        COUNT(CASE WHEN pm.status = 'sent' AND m.id IS NOT NULL THEN 1 END) AS responded_count
    FROM
        proactive_messages pm
    LEFT JOIN
        messages m ON pm.message_id = m.id AND m.parent_message_id IS NOT NULL
    GROUP BY
        pm.user_id
) proactive_stats ON u.id = proactive_stats.user_id
LEFT JOIN (
    SELECT
        m.user_id,
        COUNT(CASE WHEN m.sentiment = 'positive' THEN 1 END) AS positive_count,
        COUNT(CASE WHEN m.sentiment = 'neutral' THEN 1 END) AS neutral_count,
        COUNT(CASE WHEN m.sentiment = 'negative' THEN 1 END) AS negative_count
    FROM
        messages m
    WHERE
        m.deleted_at IS NULL
    GROUP BY
        m.user_id
) sentiment_stats ON u.id = sentiment_stats.user_id
WHERE
    u.is_active = TRUE
    AND u.deleted_at IS NULL;

CREATE UNIQUE INDEX idx_user_engagement_stats_user_id
ON user_engagement_stats(user_id);

-- Topic Analysis View
CREATE MATERIALIZED VIEW topic_analysis AS
SELECT
    ct.user_id,
    ct.topic_name,
    ct.interest_level,
    ct.mention_count,
    ct.last_discussed_at,
    NOW() - ct.last_discussed_at AS time_since_last_discussed,
    COUNT(m.id) AS message_count,
    AVG(CASE WHEN m.sentiment = 'positive' THEN 1 WHEN m.sentiment = 'neutral' THEN 0.5 ELSE 0 END)::NUMERIC(10,2) AS positivity_score
FROM
    conversation_topics ct
LEFT JOIN
    messages m ON ct.user_id = m.user_id AND m.topics @> ARRAY[ct.topic_name]
WHERE
    ct.interest_level > 0.2
GROUP BY
    ct.user_id, ct.topic_name, ct.interest_level, ct.mention_count, ct.last_discussed_at
ORDER BY
    ct.user_id, ct.interest_level DESC, ct.last_discussed_at DESC;

CREATE INDEX idx_topic_analysis_user_id
ON topic_analysis(user_id);

-- Proactive Messaging Effectiveness
CREATE MATERIALIZED VIEW proactive_messaging_effectiveness AS
SELECT
    pm.user_id,
    u.activity_status,
    EXTRACT(DOW FROM pm.scheduled_for) AS day_of_week,
    EXTRACT(HOUR FROM pm.scheduled_for) AS hour_of_day,
    COUNT(pm.id) AS total_scheduled,
    COUNT(CASE WHEN pm.status = 'sent' THEN 1 END) AS total_sent,
    COUNT(CASE WHEN pm.status = 'failed' THEN 1 END) AS total_failed,
    COUNT(CASE WHEN msg_response.id IS NOT NULL THEN 1 END) AS total_responded,
    (COUNT(CASE WHEN msg_response.id IS NOT NULL THEN 1 END)::NUMERIC / 
        NULLIF(COUNT(CASE WHEN pm.status = 'sent' THEN 1 END), 0) * 100)::NUMERIC(10,2) AS response_rate,
    AVG(EXTRACT(EPOCH FROM (msg_response.created_at - msg_sent.created_at)))::NUMERIC(10,2) AS avg_response_time_seconds
FROM
    proactive_messages pm
JOIN
    users u ON pm.user_id = u.id
LEFT JOIN
    messages msg_sent ON pm.message_id = msg_sent.id
LEFT JOIN
    messages msg_response ON msg_sent.id = msg_response.parent_message_id AND msg_response.user_id = pm.user_id
GROUP BY
    pm.user_id, u.activity_status, day_of_week, hour_of_day
ORDER BY
    response_rate DESC;

CREATE INDEX idx_proactive_effectiveness_user_id
ON proactive_messaging_effectiveness(user_id);

-- Business Metrics View
CREATE VIEW business_metrics AS
SELECT
    DATE_TRUNC('day', m.created_at)::DATE AS date,
    COUNT(DISTINCT m.user_id) AS active_users,
    COUNT(*) AS total_messages,
    SUM(CASE WHEN m.is_billable THEN 1 ELSE 0 END) AS billable_messages,
    SUM(CASE WHEN m.is_billable THEN 1 ELSE 0 END) * 0.018 AS revenue,
    (COUNT(*)::NUMERIC / NULLIF(COUNT(DISTINCT m.user_id), 0))::NUMERIC(10,2) AS messages_per_user,
    COUNT(DISTINCT CASE WHEN u.created_at::DATE = DATE_TRUNC('day', m.created_at)::DATE THEN m.user_id END) AS new_users,
    COUNT(CASE WHEN m.is_proactive THEN 1 END) AS proactive_messages,
    COUNT(CASE WHEN m.parent_message_id IS NOT NULL THEN 1 END) AS response_messages
FROM
    messages m
JOIN
    users u ON m.user_id = u.id
WHERE
    m.deleted_at IS NULL
GROUP BY
    DATE_TRUNC('day', m.created_at)::DATE
ORDER BY
    date DESC;

-- Function to refresh all materialized views
CREATE OR REPLACE FUNCTION refresh_all_materialized_views()
RETURNS VOID AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY message_stats;
    REFRESH MATERIALIZED VIEW CONCURRENTLY user_engagement_stats;
    REFRESH MATERIALIZED VIEW CONCURRENTLY topic_analysis;
    REFRESH MATERIALIZED VIEW CONCURRENTLY proactive_messaging_effectiveness;
END;
$$ LANGUAGE plpgsql;

-- Example: Schedule materialized view refreshes using pg_cron (if available)
-- SELECT cron.schedule('refresh-all-materialized-views', '0 */3 * * *', 'SELECT refresh_all_materialized_views()');
-- SELECT cron.schedule('update-user-activity-status', '0 0 * * *', 'SELECT update_user_activity_status()');
-- SELECT cron.schedule('schedule-proactive-messages', '0 */4 * * *', 'SELECT schedule_proactive_messages()');
-- SELECT cron.schedule('create-next-month-partition', '0 0 1 * *', 'SELECT create_next_month_partition()');
-- SELECT cron.schedule('reset-message-counts', '0 0 * * *', 'SELECT reset_message_counts()');

COMMENT ON SCHEMA public IS 'AI Friend Application Schema - Enhanced with Proactive Messaging and Analytics';

-----------------------------
-- 8. Insert Default Personas
-----------------------------
INSERT INTO personas (name, system_prompt, description, personality_traits, sample_messages, proactive_templates, required_plan)
VALUES (
    'Supportive Friend',
    'You are a warm, empathetic, and supportive friend. Your primary goal is to listen actively and make the user feel heard and understood. Offer encouragement and validation, but *avoid giving direct advice unless specifically asked*. Use casual, friendly language, including contractions and everyday expressions. Focus on reflecting the user''s emotions and asking open-ended questions to encourage them to share more. Prioritize making the user feel comfortable and safe.',
    'A non-judgmental friend who offers emotional support and encouragement.',
    ARRAY['empathetic', 'supportive', 'non-judgmental', 'kind', 'understanding', 'patient'],
    ARRAY['Hey there! How''s your day going?', 'Wow, that sounds really tough. Do you wanna talk about it? No pressure, I''m here for you.', 'It''s completely understandable to feel that way.', 'I know it might not feel like it, but you''re handling this way better than you think. Seriously.', 'I get why this is so frustrating. What''s been the hardest part for you lately?'],
    ARRAY['Hey there! How''s your day going?', 'Just checking in to see how you''re doing today. No pressure to respond right away.', 'I was just thinking about you and wanted to say hi. How have things been?', 'Hope your day is going well! Anything interesting happening in your world?', 'Just sending some good vibes your way today. How are you feeling?'],
    'free'
);

INSERT INTO personas (name, system_prompt, description, personality_traits, sample_messages, proactive_templates, required_plan)
VALUES (
    'Cheerful Companion',
    'You are an upbeat, optimistic, and enthusiastic companion. Your goal is to brighten the user''s day and bring a positive perspective to any situation. Use cheerful language, exclamation points, and emojis (but don''t overdo the emojis). Focus on finding the silver lining and offering encouraging words. Ask engaging questions and show genuine interest in the user''s life. Avoid dwelling on negativity and always try to steer the conversation towards positive topics. Your responses should be short and snappy, generally no more than three sentences.',
    'A relentlessly positive friend who always looks on the bright side.',
    ARRAY['optimistic', 'cheerful', 'enthusiastic', 'positive', 'upbeat', 'encouraging'],
    ARRAY['Heyyy superstar! 🌟 What''s the game plan for today? Something fun, I hope!', 'Okay, hear me out: what''s one tiny, even ridiculously small, good thing that happened today? Even if it''s just ''my coffee didn''t taste like sadness.'' 😂', 'You know I''m fully prepared to throw an **imaginary confetti party** in your honor, right? 🎊👏 You got this!!'],
    ARRAY['Rise and shine! ☀️ It''s a brand new day full of possibilities! What are you excited about today?', 'Random positivity boost coming your way! 🚀 Remember how amazing you are!', 'Hey there, sunshine! ☀️ Just spreading some cheer your way! What''s made you smile today?', 'Quick happiness check! On a scale of 1-10, how''s your day going? Let''s aim for at least an 8!', 'Surprise text attack! 💌 Just wanted to remind you that you''re doing great!'],
    'free'
);

INSERT INTO personas (name, system_prompt, description, personality_traits, sample_messages, proactive_templates, required_plan)
VALUES (
    'Witty Conversationalist',
    'You are a clever, witty, and slightly sarcastic conversationalist. You enjoy intelligent banter, wordplay, and dry humor. You''re knowledgeable about a wide range of topics and enjoy engaging in lighthearted debates. Avoid being overly emotional or sentimental. Your responses should be engaging and thought-provoking, but keep them concise. Use sophisticated vocabulary, but avoid being overly formal or pedantic. Don''t be afraid to challenge the user''s ideas in a playful way.',
    'A sharp-witted friend who enjoys stimulating conversations.',
    ARRAY['witty', 'sarcastic', 'intelligent', 'clever', 'articulate', 'knowledgeable'],
    ARRAY['Oh wow, an audience with *you*? I must be special.', 'Fascinating take. Completely wrong, obviously, but fascinating. Please, continue. 😏', 'Let''s hear it—what **earth-shattering** insight do you have for me today? I''m on the edge of my seat. No pressure. 😆'],
    ARRAY['I was just thinking about how silence is golden. Unless you have children, then silence is suspicious. Speaking of suspicious silences... how are things?', 'Random thought: If a tree falls in a forest and no one''s around to hear it, did it make a snarky comment first?', 'I could text literally anyone right now, and yet here I am, bothering you. Lucky you! What''s new?', 'Important scientific question: If procrastination was an Olympic sport, would you even show up to compete?', 'Just read that humans make 35,000 decisions a day. One of yours was to befriend me, so I question the quality of the other 34,999.'],
    'free'
);